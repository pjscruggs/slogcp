// Copyright 2025 Patrick J. Scruggs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package slogcphttp

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"strconv"
	"strings"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"

	"github.com/pjscruggs/slogcp"
)

// Transport returns an http.RoundTripper that injects trace context and derives
// a logger per outbound request.
func Transport(base http.RoundTripper, opts ...Option) http.RoundTripper {
	cfg := applyOptions(opts)
	if base == nil {
		base = http.DefaultTransport
	}

	projectID := strings.TrimSpace(cfg.projectID)
	if projectID == "" {
		projectID = strings.TrimSpace(slogcp.DetectRuntimeInfo().ProjectID)
	}

	return roundTripper{
		base:      base,
		cfg:       cfg,
		projectID: projectID,
	}
}

type roundTripper struct {
	base      http.RoundTripper
	cfg       *config
	projectID string
}

// RoundTrip instruments the outbound request, attaching context and forwarding to the base transport.
func (t roundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	if req == nil {
		return t.handleNilRequest()
	}

	cfg := t.cfg
	ctx := req.Context()
	scope := newClientScope(req, time.Now(), cfg)
	attrs := t.buildAttrs(ctx, req, scope)
	requestLogger := loggerWithAttrs(t.baseLogger(ctx), attrs)

	ctx = t.attachContext(ctx, scope, requestLogger)
	req = req.WithContext(ctx)

	t.injectTrace(ctx, req)

	return t.finishRoundTrip(req, scope)
}

// handleNilRequest preserves behavior for nil requests while wrapping errors.
func (t roundTripper) handleNilRequest() (*http.Response, error) {
	resp, err := t.base.RoundTrip(nil)
	if err != nil {
		return nil, fmt.Errorf("round trip nil request: %w", err)
	}
	return resp, nil
}

// buildAttrs collects default, trace, and enriched attributes for outbound requests.
func (t roundTripper) buildAttrs(ctx context.Context, req *http.Request, scope *RequestScope) []slog.Attr {
	traceAttrs, _ := slogcp.TraceAttributes(ctx, t.projectID)
	attrs := scope.loggerAttrs(t.cfg, traceAttrs)
	attrs = t.applyEnrichers(attrs, req, scope)
	return t.applyTransformers(attrs, req, scope)
}

// applyEnrichers appends attributes generated by attrEnrichers.
func (t roundTripper) applyEnrichers(attrs []slog.Attr, req *http.Request, scope *RequestScope) []slog.Attr {
	for _, enricher := range t.cfg.attrEnrichers {
		if enricher == nil {
			continue
		}
		if extra := enricher(req, scope); len(extra) > 0 {
			attrs = append(attrs, extra...)
		}
	}
	return attrs
}

// applyTransformers runs attribute transformers in order.
func (t roundTripper) applyTransformers(attrs []slog.Attr, req *http.Request, scope *RequestScope) []slog.Attr {
	for _, transformer := range t.cfg.attrTransformers {
		if transformer == nil {
			continue
		}
		attrs = transformer(attrs, req, scope)
	}
	return attrs
}

// baseLogger returns the configured logger or resolves one from context.
func (t roundTripper) baseLogger(ctx context.Context) *slog.Logger {
	if t.cfg.logger != nil {
		return t.cfg.logger
	}
	return slogcp.Logger(ctx)
}

// attachContext injects logger and scope into the request context.
func (t roundTripper) attachContext(ctx context.Context, scope *RequestScope, logger *slog.Logger) context.Context {
	ctx = slogcp.ContextWithLogger(ctx, logger)
	return context.WithValue(ctx, requestScopeKey{}, scope)
}

// finishRoundTrip finalizes scope metrics and wraps errors from the base transport.
func (t roundTripper) finishRoundTrip(req *http.Request, scope *RequestScope) (*http.Response, error) {
	resp, err := t.base.RoundTrip(req)
	elapsed := time.Since(scope.Start())

	if resp != nil {
		scope.finalize(resp.StatusCode, resp.ContentLength, elapsed)
		if err != nil {
			return resp, fmt.Errorf("round trip request: %w", err)
		}
		return resp, nil
	}

	scope.finalize(0, scope.ResponseSize(), elapsed)
	if err != nil {
		return nil, fmt.Errorf("round trip request: %w", err)
	}
	return nil, fmt.Errorf("round trip request: received no response and no error")
}

// injectTrace injects OpenTelemetry and optional legacy trace headers onto the request.
func (t roundTripper) injectTrace(ctx context.Context, req *http.Request) {
	if t.cfg != nil && !t.cfg.propagateTrace {
		return
	}

	propagator := t.cfg.propagators
	if propagator == nil {
		propagator = otel.GetTextMapPropagator()
	}
	if propagator != nil {
		propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))
	}

	if !t.cfg.injectLegacyXCTC {
		return
	}

	if req.Header.Get(XCloudTraceContextHeader) != "" {
		return
	}

	sc := trace.SpanContextFromContext(ctx)
	if !sc.IsValid() {
		return
	}

	req.Header.Set(
		XCloudTraceContextHeader,
		slogcp.BuildXCloudTraceContext(sc.TraceID().String(), sc.SpanID().String(), sc.IsSampled()),
	)
}

// newClientScope builds a RequestScope describing the outbound HTTP request.
func newClientScope(req *http.Request, start time.Time, cfg *config) *RequestScope {
	scope := &RequestScope{
		start:       start,
		method:      req.Method,
		requestSize: req.ContentLength,
		outbound:    true,
	}

	if req.URL != nil {
		scope.target = req.URL.Path
		scope.query = req.URL.RawQuery
		scope.scheme = req.URL.Scheme
		scope.host = req.URL.Host
	}
	scope.userAgent = req.Header.Get("User-Agent")
	if cfg.includeClientIP {
		scope.clientIP, scope.peerPort = outboundHostPort(req)
	}

	scope.status.Store(http.StatusOK)
	scope.latencyNS.Store(-1)
	return scope
}

// outboundHost extracts the host name from the outbound request for logging.
func outboundHost(req *http.Request) string {
	host, _ := outboundHostPort(req)
	return host
}

// outboundHostPort extracts the host and port from the outbound request for logging.
func outboundHostPort(req *http.Request) (string, int) {
	if req == nil {
		return "", 0
	}
	if req.URL != nil && req.URL.Host != "" {
		if host, port, err := splitHostPort(req.URL.Host); err == nil {
			return host, port
		}
		return strings.Trim(req.URL.Host, "[]"), 0
	}
	if req.Host != "" {
		if host, port, err := splitHostPort(req.Host); err == nil {
			return host, port
		}
		return strings.Trim(req.Host, "[]"), 0
	}
	return "", 0
}

func splitHostPort(hostport string) (string, int, error) {
	hostport = strings.TrimSpace(hostport)
	host, portStr, err := net.SplitHostPort(hostport)
	if err != nil {
		return "", 0, err
	}
	port, err := strconv.Atoi(portStr)
	if err != nil {
		return host, 0, nil
	}
	return host, port, nil
}
