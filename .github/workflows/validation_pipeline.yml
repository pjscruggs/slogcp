name: Validation Pipeline
on:
  pull_request:
    branches: [ main ]
  pull_request_target:
    branches: [ main ]
    types: [opened, reopened, synchronize]
  merge_group:
    branches: [ main ]
  workflow_dispatch:
  workflow_call:

permissions:
  contents: write
  pull-requests: read
  security-events: write
  checks: write

jobs:
  # -----------------------------
  # VALIDATION (runs actual code)
  # -----------------------------
  validation:
    if: |
      github.event_name == 'pull_request' ||
      github.event_name == 'merge_group' ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'workflow_call'
    name: Fix and Validate Code
    runs-on: ubuntu-latest
    env:
      GOTOOLCHAIN: auto
    steps:
      - name: 🛒 Checkout Code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref || github.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 Determine branch name
        id: get-branch
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          if [[ "$EVENT_NAME" == "pull_request" ]]; then
            echo "BRANCH_NAME=$PR_HEAD_REF" >> "$GITHUB_OUTPUT"
          else
            echo "BRANCH_NAME=${GITHUB_REF#refs/heads/}" >> "$GITHUB_OUTPUT"
          fi

      - name: 🔢 Determine Go version
        id: go-version
        run: |
          GO_VERSION=$(grep '^go ' go.mod | awk '{print $2}')
          if [ -z "$GO_VERSION" ]; then
            echo "Unable to determine Go version from go.mod" >&2
            exit 1
          fi

          GO_VERSION="$GO_VERSION" python3 .github/scripts/resolve_go_version.py

      - name: 🏗️ Set up Go
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6
        with:
          go-version: ${{ steps.go-version.outputs.version }}
          cache: true
      
      - name: 🛠️ Install golangci-lint
        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8
        with:
          version: v2.1.5
          install-mode: goinstall
          
      - name: ✨ Apply Go Formatting
        run: |
          go install golang.org/x/tools/cmd/goimports@latest
          gofmt -w .
          goimports -local github.com/pjscruggs/slogcp -w .

      - name: 🧹 Ensure module metadata is tidy
        run: |
          go mod tidy

      - name: 📅🕰️ Get current year in US Central Time
        id: year
        run: |
          YEAR=$(TZ='America/Chicago' date +%Y)
          echo "YEAR=$YEAR" >> $GITHUB_OUTPUT
      
      - name: 📄⚙️📅 Update license year in config
        run: |
          if [ "${{ steps.year.outputs.YEAR }}" -gt "2025" ]; then
            sed -i 's/copyright-year: .*/copyright-year: "2025-${{ steps.year.outputs.YEAR }}"/g' .licenserc.yaml
            echo "📅⬆️ Updated year to 2025-${{ steps.year.outputs.YEAR }}"
          else
            echo "📅✅ Keeping year as 2025"
          fi
      
      - name: 📄🩹 Fix License Headers
        id: fix-license
        uses: apache/skywalking-eyes/header@5c5b974209f0de5d905f37deb69369068ebfc15c # v0.7.0
        with:
          mode: fix
          config: .licenserc.yaml
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ♻️ Restore Go toolchain (post-license-fix)
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6
        with:
          go-version: ${{ steps.go-version.outputs.version }}
          cache: true
      
      - name: 🧐 Apply Lint Fixes
        run: golangci-lint run --fix ./...
        continue-on-error: true
      
      - name: 💾 Commit All Fixes
        if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git diff --quiet || {
            git add .
            git commit -m "chore: apply code maintenance (formatting, linting, license headers)"
            git push origin ${{ steps.get-branch.outputs.BRANCH_NAME }}
          }
          
      - name: 🔄 Re-checkout after fixes if needed
        run: |
          if git diff --quiet origin/${{ steps.get-branch.outputs.BRANCH_NAME }} HEAD; then
            echo "No changes were committed, skipping re-checkout"
          else
            echo "Changes were committed, re-checking out latest code"
            git fetch
            git checkout origin/${{ steps.get-branch.outputs.BRANCH_NAME }}
          fi

      - name: ✅ Ensure working tree is clean
        run: |
          if ! git diff --quiet; then
            echo "Working tree has uncommitted changes after maintenance steps."
            git status --short
            exit 1
          fi

      - name: 🧐 Verify Linting
        run: golangci-lint run ./...
      
      - name: 📄✅ Verify License Headers
        uses: apache/skywalking-eyes/header@5c5b974209f0de5d905f37deb69369068ebfc15c # v0.7.0
        with:
          mode: check
          config: .licenserc.yaml
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ♻️ Restore Go toolchain (pre-tests)
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6
        with:
          go-version: ${{ steps.go-version.outputs.version }}
          cache: true

      - name: Install Go Test Tools
        run: |
          go install github.com/mfridman/tparse@ba2512e7be150bfcbd6f6220d517d3741f8f2f75

      - name: Run Go Tests
        if: success()
        id: go-tests
        run: |
          go test -json -race -coverprofile=coverage.out ./... | tparse -all -notests

      - name: Verify Example Modules
        if: success()
        run: |
          set -euo pipefail
          if [ ! -d ".examples" ]; then
            echo "No .examples directory found; skipping example verification."
            exit 0
          fi

          examples_found=0
          while IFS= read -r -d '' mod; do
            examples_found=1
            dir=$(dirname "$mod")
            echo "::group::go test $dir"
            (cd "$dir" && go test ./...)
            echo "::endgroup::"
          done < <(find .examples -name go.mod -print0)

          if [ "$examples_found" -eq 0 ]; then
            echo "No example go.mod files found under .examples; skipping."
          fi

      - name: Print Coverage Report
        if: always()
        run: |
          echo "--- Test Coverage ---"
          if [ -f coverage.out ]; then
            cat coverage.out
          else
            echo "Coverage file (coverage.out) not found."
          fi
          echo "---------------------"
      
      - name: 🛡️🔍 Run Vulnerability Check
        run: |
          echo "Installing govulncheck..."
          go install golang.org/x/vuln/cmd/govulncheck@b9d319d7ce41a3991288754d7ec709166dce2619
          echo "Running vulnerability check..."
          govulncheck ./...

  # -------------------------------------------------------
  # E2E GATEKEEPER (PR-target; API-only; uses repo secrets)
  # -------------------------------------------------------
  e2e_gatekeeper:
    name: E2E Test Gatekeeper
    if: github.event_name == 'pull_request_target'
    runs-on: ubuntu-latest
    permissions:
      checks: write
      contents: read
    
    steps:
      - name: Determine E2E Trigger Type
        id: trigger_type
        run: |
          if [[ "${{ github.actor }}" == "renovate[bot]" ]]; then
            echo "should_auto_trigger=true" >> $GITHUB_OUTPUT
          else
            echo "should_auto_trigger=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Manual Gatekeeper Check (queued)
        if: steps.trigger_type.outputs.should_auto_trigger == 'false'
        id: manual_check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const checkName = 'E2E Tests (GCP)';
            const sha = context.payload.pull_request.head.sha;
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: checkName,
              head_sha: sha,
              status: 'queued',
              output: { title: checkName, summary: 'E2E tests are queued...' }
            });
            core.setOutput('check_run_id', checkRun.id);

      - name: Update Check for Manual Trigger Required
        if: steps.trigger_type.outputs.should_auto_trigger == 'false'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ steps.manual_check.outputs.check_run_id }},
              status: 'completed',
              conclusion: 'action_required',
              completed_at: new Date().toISOString(),
              output: {
                title: 'E2E Tests (GCP) - Manual Trigger Required',
                summary: `⚠️ E2E tests require manual trigger by a maintainer after code review.

                A repository maintainer can trigger E2E tests by:
                1. Going to Actions → "Manual E2E Test Trigger" workflow
                2. Click "Run workflow" and enter PR number: ${{ github.event.pull_request.number }}

                This check must pass before the PR can be merged.`
              }
            });

      - name: Generate E2E Run ID
        if: steps.trigger_type.outputs.should_auto_trigger == 'true'
        id: run_id
        shell: bash
        run: |
          echo "e2e_run_id=$(date -u +%Y%m%dT%H%M%S)-$RANDOM" >> "$GITHUB_OUTPUT"

      - name: Generate App Token for Check Run
        if: steps.trigger_type.outputs.should_auto_trigger == 'true'
        id: check_run_token
        uses: actions/create-github-app-token@67018539274d69449ef7c02e8e71183d1719ab42 # v2
        with:
          app-id: ${{ secrets.E2E_APP_ID }}
          private-key: ${{ secrets.E2E_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.event.repository.name }}

      - name: Create Run-Scoped E2E Check (in progress)
        if: steps.trigger_type.outputs.should_auto_trigger == 'true'
        id: create_run_check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          github-token: ${{ steps.check_run_token.outputs.token }}
          script: |
            const runId = '${{ steps.run_id.outputs.e2e_run_id }}';
            const name = `E2E Tests (GCP) — ${runId}`;
            const sha = context.payload.pull_request.head.sha;
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name,
              head_sha: sha,
              status: 'in_progress',
              external_id: runId,
              started_at: new Date().toISOString(),
              output: {
                title: name,
                summary: `E2E run ${runId} initiated. Waiting for validation to pass...`
              }
            });
            core.setOutput('check_run_id', checkRun.id);

      - name: Wait for Validation to Succeed
        if: steps.trigger_type.outputs.should_auto_trigger == 'true'
        id: wait_validation
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = context.payload.pull_request.head.sha;
            const targetCheckName = 'Fix and Validate Code';
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            let ok = false;

            for (let i = 0; i < 80; i++) {
              const { data } = await github.rest.checks.listForRef({ owner, repo, ref, filter: 'latest' });
              const cr = data.check_runs.find(r => r.name === targetCheckName);
              if (!cr || cr.status === 'queued' || cr.status === 'in_progress') {
                await sleep(15000);
                continue;
              }
              if (cr.status === 'completed' && cr.conclusion === 'success') { ok = true; break; }
              core.setFailed(`Validation job conclusion: ${cr?.conclusion || 'unknown'}`);
              return;
            }
            if (!ok) core.setFailed('Validation job did not complete in time');
            core.setOutput('ok', ok ? 'true' : 'false');

      - name: Detect secret availability
        if: |
          steps.trigger_type.outputs.should_auto_trigger == 'true' &&
          steps.wait_validation.outputs.ok == 'true'
        id: have_secrets
        run: |
          if [ -n "${{ secrets.E2E_APP_ID }}" ] && [ -n "${{ secrets.E2E_APP_PRIVATE_KEY }}" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate App Token for E2E Dispatch
        if: |
          steps.trigger_type.outputs.should_auto_trigger == 'true' &&
          steps.wait_validation.outputs.ok == 'true' &&
          steps.have_secrets.outputs.ok == 'true'
        id: app_token
        uses: actions/create-github-app-token@67018539274d69449ef7c02e8e71183d1719ab42 # v2
        with:
          app-id: ${{ secrets.E2E_APP_ID }}
          private-key: ${{ secrets.E2E_APP_PRIVATE_KEY }}
          owner: pjscruggs
          repositories: slogcp-test

      - name: Dispatch E2E Tests
        if: steps.app_token.outputs.token != ''
        uses: peter-evans/repository-dispatch@5fc4efd1a4797ddb68ffd0714a238564e4cc0e6f # v4
        with:
          token: ${{ steps.app_token.outputs.token }}
          repository: pjscruggs/slogcp-test
          event-type: e2e-test
          client-payload: |
            {
              "lib_repo_full_name": "${{ github.repository }}",
              "pr_sha": "${{ github.event.pull_request.head.sha }}",
              "pr_number": "${{ github.event.pull_request.number }}",
              "lib_run_id": "${{ github.run_id }}",
              "check_run_id": "${{ steps.create_run_check.outputs.check_run_id }}",
              "e2e_run_id": "${{ steps.run_id.outputs.e2e_run_id }}"
            }

      - name: Update run-scoped check when auto path cannot dispatch
        if: |
          steps.trigger_type.outputs.should_auto_trigger == 'true' &&
          (steps.wait_validation.outputs.ok != 'true' ||
           steps.have_secrets.outputs.ok != 'true' ||
           steps.app_token.outputs.token == '')
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          github-token: ${{ steps.check_run_token.outputs.token }}
          script: |
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ steps.create_run_check.outputs.check_run_id }},
              status: 'completed',
              conclusion: 'action_required',
              completed_at: new Date().toISOString(),
              output: {
                title: 'E2E Tests (GCP) - Manual Trigger Required',
                summary: `Secrets not available or validation not successful. A maintainer can run the "Manual E2E Test Trigger" workflow with PR #${{ github.event.pull_request.number }}.`
              }
            });

